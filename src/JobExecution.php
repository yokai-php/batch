<?php

declare(strict_types=1);

namespace Yokai\Batch;

use DateInterval;
use DateTime;
use DateTimeInterface;
use Psr\Log\LoggerInterface;
use Throwable;
use Yokai\Batch\Exception\ImmutablePropertyException;
use Yokai\Batch\Factory\JobExecutionIdGeneratorInterface;
use Yokai\Batch\Job\JobExecutionAwareInterface;
use Yokai\Batch\Job\JobWithChildJobs;

/**
 * This object contains all information related to a job execution.
 * It is created anytime a job is triggered.
 *
 * You can obtain the execution by implementing {@see JobExecutionAwareInterface}.
 */
final class JobExecution
{
    /**
     * The job execution id (generated by {@see JobExecutionIdGeneratorInterface}).
     */
    private string $id;

    /**
     * The job name.
     */
    private string $jobName;

    /**
     * The status in which the job execution is.
     */
    private BatchStatus $status;

    /**
     * The date and time when the job started.
     * If null, the job is not started yet.
     */
    private ?DateTimeInterface $startTime = null;

    /**
     * The date and time when the job finished.
     * If null, the job is not finished yet.
     */
    private ?DateTimeInterface $endTime = null;

    /**
     * List of failures that occurred in the execution.
     * @var Failure[]
     */
    private array $failures = [];

    /**
     * List of warnings that where registered during the execution.
     * @var Warning[]
     */
    private array $warnings = [];

    /**
     * The summary information collected during execution.
     */
    private Summary $summary;

    /**
     * The parameters provided before job execution.
     */
    private JobParameters $parameters;

    /**
     * The parent execution.
     * Most of the time null, filled whenever using a {@see JobWithChildJobs}.
     * Inverse side of {@see JobExecution::$childExecutions}
     */
    private ?JobExecution $parentExecution;

    /**
     * The children executions.
     * Most of the time empty, filled whenever using a {@see JobWithChildJobs}.
     * Inverse side of {@see JobExecution::$parentExecution}
     * @var JobExecution[]
     */
    private array $childExecutions = [];

    /**
     * Logs collected during job execution.
     * Filled via {@see JobExecution::$logger}.
     */
    private JobExecutionLogs $logs;

    /**
     * Private job execution logger.
     * Will fill {@see JobExecution::$logs}.
     */
    private LoggerInterface $logger;

    private function __construct(
        ?JobExecution $parentExecution,
        string $id,
        string $jobName,
        ?BatchStatus $status,
        ?JobParameters $parameters,
        ?Summary $summary,
        ?JobExecutionLogs $logs
    ) {
        $this->parentExecution = $parentExecution;
        $this->id = $id;
        $this->jobName = $jobName;
        $this->status = $status ?: new BatchStatus(BatchStatus::PENDING);
        $this->parameters = $parameters ?: new JobParameters();
        $this->summary = $summary ?: new Summary();
        $this->logs = $parentExecution ? $parentExecution->getLogs() : ($logs ?: new JobExecutionLogs());
        $this->logger = $parentExecution ? $parentExecution->getLogger() : new JobExecutionLogger($this->logs);
    }

    /**
     * Create a root execution of a job (ie : that has no parent).
     */
    public static function createRoot(
        string $id,
        string $jobName,
        BatchStatus $status = null,
        JobParameters $parameters = null,
        Summary $summary = null,
        JobExecutionLogs $logs = null
    ): self {
        return new self(null, $id, $jobName, $status, $parameters, $summary, $logs);
    }

    /**
     * Create a child execution of a job (ie : that has a parent).
     */
    public static function createChild(
        JobExecution $parent,
        string $jobName,
        BatchStatus $status = null,
        JobParameters $parameters = null,
        Summary $summary = null
    ): self {
        return new self($parent, $parent->getId(), $jobName, $status, $parameters, $summary, null);
    }

    public function getId(): string
    {
        return $this->id;
    }

    public function getJobName(): string
    {
        return $this->jobName;
    }

    public function getStatus(): BatchStatus
    {
        return $this->status;
    }

    public function setStatus(int $status): void
    {
        if ($status > $this->status->getValue()) {
            $this->status = new BatchStatus($status);
        }
    }

    public function getStartTime(): ?DateTimeInterface
    {
        return $this->startTime;
    }

    public function getEndTime(): ?DateTimeInterface
    {
        return $this->endTime;
    }

    /**
     * Build a {@see DateInterval}
     * from {@see JobExecution::$startTime} to {@see JobExecution::$endTime}.
     */
    public function getDuration(): DateInterval
    {
        $now = new DateTime();
        $start = $this->startTime ?: $now;
        $end = $this->endTime ?: $now;

        return $start->diff($end);
    }

    /**
     * @throws ImmutablePropertyException If {@see JobExecution::$startTime} is not null.
     */
    public function setStartTime(?DateTimeInterface $startTime): void
    {
        if ($this->startTime !== null) {
            throw new ImmutablePropertyException(self::class, 'startTime');
        }

        $this->startTime = $startTime;
    }

    /**
     * @throws ImmutablePropertyException If {@see JobExecution::$endTime} is not null.
     */
    public function setEndTime(?DateTimeInterface $endTime): void
    {
        if ($this->endTime !== null) {
            throw new ImmutablePropertyException(self::class, 'endTime');
        }

        $this->endTime = $endTime;
    }

    public function getSummary(): Summary
    {
        return $this->summary;
    }

    /**
     * Create a child job execution of this execution.
     */
    public function createChildExecution(string $childName): JobExecution
    {
        return self::createChild($this, $childName);
    }

    public function getParentExecution(): ?JobExecution
    {
        return $this->parentExecution;
    }

    /**
     * Navigates through parents until the root is found.
     */
    public function getRootExecution(): JobExecution
    {
        $execution = $this;
        while (null !== $parent = $execution->getParentExecution()) {
            $execution = $parent;
        }

        return $execution;
    }

    /**
     * @return JobExecution[]
     */
    public function getChildExecutions(): array
    {
        return array_values($this->childExecutions);
    }

    /**
     * Add a child execution.
     */
    public function addChildExecution(JobExecution $execution): void
    {
        $this->childExecutions[$execution->getJobName()] = $execution;
    }

    /**
     * Get a child execution for which the job name is $childName.
     * Returns null if that execution does not exist.
     */
    public function getChildExecution(string $childName): ?JobExecution
    {
        return $this->childExecutions[$childName] ?? null;
    }

    public function getParameters(): JobParameters
    {
        return $this->parameters;
    }

    /**
     * Get a parameter value.
     */
    public function getParameter(string $name): mixed
    {
        return $this->parameters->get($name);
    }

    /**
     * @return Failure[]
     */
    public function getFailures(): array
    {
        return $this->failures;
    }

    /**
     * Add a failure to the execution.
     */
    public function addFailure(Failure $failure, bool $log = true): void
    {
        $this->failures[] = $failure;
        if ($log) {
            $this->logger->error((string)$failure);
        }
    }

    /**
     * Add a failure, build from exception, to the execution.
     *
     * @phpstan-param array<string, string> $parameters
     */
    public function addFailureException(Throwable $exception, array $parameters = [], bool $log = true): void
    {
        $this->addFailure(Failure::fromException($exception, $parameters), $log);
    }

    /**
     * Get failures from this execution and its children (recursively).
     *
     * @return Failure[]
     */
    public function getAllFailures(): array
    {
        $all = [];
        foreach ($this->failures as $failure) {
            $all[] = $failure;
        }
        foreach ($this->getChildExecutions() as $child) {
            foreach ($child->getAllFailures() as $failure) {
                $all[] = $failure;
            }
        }

        return $all;
    }

    /**
     * @return Warning[]
     */
    public function getWarnings(): array
    {
        return $this->warnings;
    }

    /**
     * Add a warning to the execution.
     */
    public function addWarning(Warning $warning, bool $log = true): void
    {
        $this->warnings[] = $warning;
        if ($log) {
            $this->logger->warning((string)$warning, $warning->getContext());
        }
    }

    /**
     * Get warnings from this execution and its children (recursively).
     *
     * @return Warning[]
     */
    public function getAllWarnings(): array
    {
        $all = [];
        foreach ($this->warnings as $warning) {
            $all[] = $warning;
        }
        foreach ($this->getChildExecutions() as $child) {
            foreach ($child->getAllWarnings() as $warning) {
                $all[] = $warning;
            }
        }

        return $all;
    }

    public function getLogs(): JobExecutionLogs
    {
        return $this->logs;
    }

    public function getLogger(): LoggerInterface
    {
        return $this->logger;
    }
}
